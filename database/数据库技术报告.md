# EPMS 人事管理系统 - 数据库技术报告

## 目录
1. [数据库概述](#数据库概述)
2. [数据库设计原则](#数据库设计原则)
3. [表结构设计](#表结构设计)
4. [索引设计](#索引设计)
5. [外键约束](#外键约束)
6. [视图（View）](#视图view)
7. [触发器（Trigger）](#触发器trigger)
8. [存储过程（Stored Procedure）](#存储过程stored-procedure)
9. [自定义函数（Function）](#自定义函数function)
10. [事件调度器（Event Scheduler）](#事件调度器event-scheduler)
11. [数据完整性约束](#数据完整性约束)
12. [数据库技术总结](#数据库技术总结)

---

## 数据库概述

### 基本信息
- **数据库名称**: `epms_final_db`
- **字符集**: `utf8mb4`
- **排序规则**: `utf8mb4_unicode_ci`
- **存储引擎**: `InnoDB`
- **数据库用途**: 企业人事管理系统（Employee Personnel Management System）

### 数据库规模
- **数据表总数**: 12张
- **视图总数**: 5个
- **触发器总数**: 6个
- **存储过程总数**: 5个
- **自定义函数总数**: 3个
- **事件调度器总数**: 2个

---

## 数据库设计原则

### 1. 规范化设计
- **第一范式（1NF）**: 所有字段都是原子值，不可再分
- **第二范式（2NF）**: 消除部分函数依赖，所有非主键字段完全依赖于主键
- **第三范式（3NF）**: 消除传递依赖，非主键字段之间不存在依赖关系

### 2. 实体关系设计
- **一对多关系**: 部门-员工、职位-员工、员工-合同、员工-考勤等
- **多对多关系**: 员工-培训课程（通过中间表 `emp_training_relation` 实现）
- **一对一关系**: 系统用户-员工（通过 `related_emp_id` 实现）

### 3. 数据完整性保障
- 主键约束保证实体完整性
- 外键约束保证参照完整性
- CHECK约束保证域完整性
- 触发器保证业务逻辑完整性

---

## 表结构设计

### 1. 基础表

#### 1.1 部门表（department）
```sql
CREATE TABLE department (
    dept_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '部门编号',
    dept_name VARCHAR(50) NOT NULL UNIQUE COMMENT '部门名称',
    location VARCHAR(100) COMMENT '地址'
) ENGINE=InnoDB COMMENT='部门表';
```

**设计要点**:
- 使用 `AUTO_INCREMENT` 自动生成主键
- `dept_name` 设置 `UNIQUE` 约束，确保部门名称唯一
- 使用 `InnoDB` 引擎支持事务和外键

#### 1.2 职位表（position）
```sql
CREATE TABLE position (
    pos_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '职位编号',
    pos_name VARCHAR(50) NOT NULL UNIQUE COMMENT '职位名称',
    base_salary DECIMAL(10, 2) DEFAULT 0.00 COMMENT '基本工资',
    level VARCHAR(20) COMMENT '职级'
) ENGINE=InnoDB COMMENT='职位表';
```

**设计要点**:
- `base_salary` 使用 `DECIMAL(10, 2)` 精确存储金额
- 职位名称唯一性约束

### 2. 核心业务表

#### 2.1 员工档案表（employee）
```sql
CREATE TABLE employee (
    emp_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '员工工号',
    dept_id INT COMMENT '所属部门',
    pos_id INT COMMENT '当前职位',
    name VARCHAR(50) NOT NULL COMMENT '姓名',
    gender ENUM('男', '女') DEFAULT '男',
    id_card VARCHAR(18) NOT NULL UNIQUE COMMENT '身份证号',
    phone VARCHAR(20) COMMENT '电话',
    politics_status VARCHAR(20) COMMENT '政治面貌',
    hukou_type VARCHAR(20) COMMENT '户口状况',
    hire_date DATE NOT NULL COMMENT '入职日期',
    status ENUM('试用期', '在职', '离职') DEFAULT '试用期' COMMENT '状态',
    
    INDEX idx_emp_name (name),
    CONSTRAINT fk_emp_dept FOREIGN KEY (dept_id) REFERENCES department (dept_id) ON DELETE SET NULL,
    CONSTRAINT fk_emp_pos FOREIGN KEY (pos_id) REFERENCES position (pos_id) ON DELETE SET NULL
) ENGINE=InnoDB COMMENT='员工档案主表';
```

**设计要点**:
- 使用 `ENUM` 类型限制字段取值范围，提高数据一致性
- `id_card` 设置唯一约束，防止重复身份证号
- 外键使用 `ON DELETE SET NULL`，删除部门/职位时保留员工记录
- 添加姓名索引提高查询性能

#### 2.2 合同管理表（contract）
```sql
CREATE TABLE contract (
    contract_id INT AUTO_INCREMENT PRIMARY KEY,
    emp_id INT NOT NULL,
    type ENUM('固定期限', '无固定期限', '实习') NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE,
    status ENUM('有效', '过期', '解除') DEFAULT '有效',
    
    INDEX idx_contract_alert (status, end_date),
    CONSTRAINT fk_contract_emp FOREIGN KEY (emp_id) REFERENCES employee (emp_id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='合同信息表';
```

**设计要点**:
- 复合索引 `idx_contract_alert` 优化合同预警查询
- 外键使用 `ON DELETE CASCADE`，员工删除时级联删除合同

#### 2.3 考勤记录表（attendance）
```sql
CREATE TABLE attendance (
    record_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    emp_id INT NOT NULL,
    work_date DATE NOT NULL,
    type ENUM('正常', '迟到', '早退', '旷工', '请假', '出差') NOT NULL,
    hours DECIMAL(4, 1) DEFAULT 8.0 COMMENT '时长',
    remarks VARCHAR(100),
    
    INDEX idx_att_emp_date (emp_id, work_date),
    CONSTRAINT fk_att_emp FOREIGN KEY (emp_id) REFERENCES employee (emp_id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='考勤记录表';
```

**设计要点**:
- 使用 `BIGINT` 主键支持大量考勤记录
- 复合索引 `(emp_id, work_date)` 优化按员工和日期查询
- `hours` 使用 `DECIMAL(4, 1)` 精确存储工作时长

#### 2.4 奖惩记录表（reward_punish）
```sql
CREATE TABLE reward_punish (
    rp_id INT AUTO_INCREMENT PRIMARY KEY,
    emp_id INT NOT NULL,
    type ENUM('奖励', '惩罚') NOT NULL,
    amount DECIMAL(10, 2) DEFAULT 0.00 COMMENT '金额(正负)',
    event_date DATE NOT NULL,
    reason VARCHAR(255) COMMENT '原因',
    
    INDEX idx_rp_emp_date (emp_id, event_date),
    CONSTRAINT fk_rp_emp FOREIGN KEY (emp_id) REFERENCES employee (emp_id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='奖惩记录表';
```

**设计要点**:
- `amount` 支持正负值，奖励为正，惩罚为负
- 复合索引优化按员工和日期查询

#### 2.5 人事变动日志表（job_change）
```sql
CREATE TABLE job_change (
    change_id INT AUTO_INCREMENT PRIMARY KEY,
    emp_id INT NOT NULL,
    change_type ENUM('入职', '转正', '调动', '晋升', '离职') NOT NULL,
    old_dept_name VARCHAR(50) COMMENT '原部门快照',
    new_dept_name VARCHAR(50) COMMENT '新部门快照',
    old_pos_name VARCHAR(50) COMMENT '原职位快照',
    new_pos_name VARCHAR(50) COMMENT '新职位快照',
    change_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    remarks VARCHAR(255) COMMENT '备注说明',
    
    INDEX idx_change_log (emp_id, change_date),
    CONSTRAINT fk_jc_emp FOREIGN KEY (emp_id) REFERENCES employee (emp_id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='人事变动日志表';
```

**设计要点**:
- 使用快照字段（`old_dept_name`, `new_dept_name` 等）保存历史状态
- `change_date` 使用 `DATETIME` 类型，精确到秒
- 默认值 `CURRENT_TIMESTAMP` 自动记录变动时间

#### 2.6 培训课程表（training_course）
```sql
CREATE TABLE training_course (
    course_id INT AUTO_INCREMENT PRIMARY KEY,
    course_name VARCHAR(100) NOT NULL,
    start_time DATETIME NOT NULL,
    end_time DATETIME NOT NULL,
    location VARCHAR(100),
    trainer VARCHAR(50)
) ENGINE=InnoDB COMMENT='培训课程表';
```

#### 2.7 员工培训关联表（emp_training_relation）
```sql
CREATE TABLE emp_training_relation (
    emp_id INT NOT NULL,
    course_id INT NOT NULL,
    score DECIMAL(5, 2) COMMENT '考核成绩',
    is_completed BOOLEAN DEFAULT FALSE,
    PRIMARY KEY (emp_id, course_id),
    CONSTRAINT fk_etr_emp FOREIGN KEY (emp_id) REFERENCES employee (emp_id) ON DELETE CASCADE,
    CONSTRAINT fk_etr_course FOREIGN KEY (course_id) REFERENCES training_course (course_id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='培训记录中间表';
```

**设计要点**:
- 使用复合主键 `(emp_id, course_id)` 实现多对多关系
- 防止同一员工重复报名同一课程

#### 2.8 系统用户表（sys_user）
```sql
CREATE TABLE sys_user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(100) NOT NULL,
    role ENUM('ADMIN', 'HR') DEFAULT 'ADMIN',
    related_emp_id INT UNIQUE,
    CONSTRAINT fk_sys_emp FOREIGN KEY (related_emp_id) REFERENCES employee (emp_id) ON DELETE SET NULL
) ENGINE=InnoDB COMMENT='系统用户表';
```

**设计要点**:
- `username` 唯一约束
- `related_emp_id` 唯一约束，实现一对一关系

### 3. 辅助表

#### 3.1 月度考勤汇总表（attendance_monthly_summary）
```sql
CREATE TABLE attendance_monthly_summary (
    summary_id INT AUTO_INCREMENT PRIMARY KEY,
    emp_id INT NOT NULL,
    month VARCHAR(7) NOT NULL,
    normal_days INT DEFAULT 0,
    late_days INT DEFAULT 0,
    absence_days INT DEFAULT 0,
    total_hours DECIMAL(6,1) DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_emp_month (emp_id, month),
    CONSTRAINT fk_summary_emp FOREIGN KEY (emp_id) REFERENCES employee (emp_id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='月度考勤汇总表';
```

**设计要点**:
- 唯一约束 `(emp_id, month)` 防止重复汇总
- 用于存储预计算的月度统计数据，提高查询性能

#### 3.2 工资调整历史表（salary_adjustment_log）
```sql
CREATE TABLE salary_adjustment_log (
    log_id INT AUTO_INCREMENT PRIMARY KEY,
    pos_id INT NOT NULL,
    pos_name VARCHAR(50),
    old_salary DECIMAL(10, 2),
    new_salary DECIMAL(10, 2),
    adjustment_rate DECIMAL(5,2) COMMENT '调整幅度%',
    adjustment_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    operator VARCHAR(50),
    CONSTRAINT fk_sal_log_pos FOREIGN KEY (pos_id) REFERENCES position (pos_id) ON DELETE CASCADE
) ENGINE=InnoDB COMMENT='工资调整历史表';
```

**设计要点**:
- 审计表设计，记录所有工资调整历史
- 保存调整前后快照，便于追溯

---

## 索引设计

### 索引类型统计
- **主键索引**: 12个（每张表一个）
- **唯一索引**: 5个（部门名称、职位名称、身份证号、用户名等）
- **普通索引**: 6个
- **复合索引**: 5个

### 索引设计原则

#### 1. 主键索引
所有表都使用 `AUTO_INCREMENT` 的整数作为主键，InnoDB 自动创建聚簇索引。

#### 2. 唯一索引
```sql
-- 示例：部门名称唯一索引
dept_name VARCHAR(50) NOT NULL UNIQUE
```
**作用**: 保证数据唯一性，同时提高查询性能

#### 3. 普通索引
```sql
-- 员工姓名索引
INDEX idx_emp_name (name)
```
**作用**: 优化按姓名查询的性能

#### 4. 复合索引
```sql
-- 合同预警复合索引
INDEX idx_contract_alert (status, end_date)

-- 考勤记录复合索引
INDEX idx_att_emp_date (emp_id, work_date)

-- 奖惩记录复合索引
INDEX idx_rp_emp_date (emp_id, event_date)

-- 人事变动日志复合索引
INDEX idx_change_log (emp_id, change_date)
```

**设计要点**:
- 复合索引遵循最左前缀原则
- 将查询频率高的字段放在前面
- 支持多字段组合查询优化

### 索引优化策略

1. **覆盖索引**: 复合索引包含查询所需的所有字段，避免回表
2. **选择性**: 在选择性高的字段上建立索引（如身份证号）
3. **查询模式**: 根据实际查询模式设计索引，如 `(emp_id, work_date)` 支持按员工和日期查询

---

## 外键约束

### 外键关系图

```
department (1) ──< (N) employee
position (1) ──< (N) employee
employee (1) ──< (N) contract
employee (1) ──< (N) attendance
employee (1) ──< (N) reward_punish
employee (1) ──< (N) job_change
employee (1) ──< (N) emp_training_relation
training_course (1) ──< (N) emp_training_relation
employee (1) ──< (1) sys_user
employee (1) ──< (N) attendance_monthly_summary
position (1) ──< (N) salary_adjustment_log
```

### 外键删除策略

#### 1. ON DELETE CASCADE（级联删除）
```sql
CONSTRAINT fk_contract_emp FOREIGN KEY (emp_id) 
    REFERENCES employee (emp_id) ON DELETE CASCADE
```
**使用场景**: 
- `contract` → `employee`
- `attendance` → `employee`
- `reward_punish` → `employee`
- `job_change` → `employee`
- `emp_training_relation` → `employee` / `training_course`

**作用**: 删除员工时，自动删除其所有相关记录，保证数据一致性

#### 2. ON DELETE SET NULL（设置为空）
```sql
CONSTRAINT fk_emp_dept FOREIGN KEY (dept_id) 
    REFERENCES department (dept_id) ON DELETE SET NULL
```
**使用场景**:
- `employee` → `department`
- `employee` → `position`
- `sys_user` → `employee`

**作用**: 删除部门/职位时，保留员工记录，但外键字段设为 NULL

### 外键约束的作用

1. **参照完整性**: 确保外键值必须存在于被引用表中
2. **数据一致性**: 防止孤立记录的产生
3. **级联操作**: 自动处理关联数据的删除和更新

---

## 视图（View）

### 视图概述
视图是虚拟表，基于查询结果创建，不存储实际数据，提供数据安全性和查询简化。

### 视图列表

#### 1. 员工安全视图（v_emp_safe_profile）
```sql
CREATE OR REPLACE VIEW v_emp_safe_profile AS
SELECT
    e.emp_id,
    e.dept_id,
    e.pos_id,
    e.name,
    e.gender,
    e.phone,
    e.hire_date,
    e.status,
    d.dept_name,
    p.pos_name,
    INSERT(e.id_card, 5, 10, '**********') AS safe_id_card
FROM employee e
LEFT JOIN department d ON e.dept_id = d.dept_id
LEFT JOIN position p ON e.pos_id = p.pos_id;
```

**技术要点**:
- 使用 `INSERT()` 函数对身份证号进行脱敏处理（保留前4位和后4位）
- 隐藏敏感信息（政治面貌、户口状况），保护隐私
- 包含完整的基本信息（姓名、性别、电话、入职日期等）
- 多表连接查询，关联部门和职位信息

**应用场景**: HR用户查询员工信息时使用，避免泄露完整身份证号等敏感数据

#### 2. 部门员工统计视图（v_dept_employee_stats）
```sql
CREATE OR REPLACE VIEW v_dept_employee_stats AS
SELECT 
    d.dept_id,
    d.dept_name,
    d.location,
    COUNT(e.emp_id) AS total_employees,
    COUNT(CASE WHEN e.status = '在职' THEN 1 END) AS active_employees,
    COUNT(CASE WHEN e.status = '试用期' THEN 1 END) AS probation_employees,
    COUNT(CASE WHEN e.status = '离职' THEN 1 END) AS resigned_employees,
    IFNULL(AVG(p.base_salary), 0) AS avg_dept_salary,
    MAX(p.base_salary) AS max_dept_salary,
    MIN(p.base_salary) AS min_dept_salary
FROM department d
LEFT JOIN employee e ON d.dept_id = e.dept_id
LEFT JOIN position p ON e.pos_id = p.pos_id
GROUP BY d.dept_id, d.dept_name, d.location;
```

**技术要点**:
- 使用 `COUNT()` 聚合函数统计员工数量
- 使用 `CASE WHEN` 条件聚合统计不同状态员工
- 使用 `AVG()`, `MAX()`, `MIN()` 计算工资统计
- `IFNULL()` 处理 NULL 值
- `LEFT JOIN` 确保所有部门都显示，即使没有员工

**应用场景**: 部门管理、统计分析

#### 3. 合同到期预警视图（v_contract_expiring_soon）
```sql
CREATE OR REPLACE VIEW v_contract_expiring_soon AS
SELECT 
    c.contract_id,
    e.emp_id,
    e.name AS emp_name,
    d.dept_name,
    p.pos_name,
    c.type AS contract_type,
    c.start_date,
    c.end_date,
    DATEDIFF(c.end_date, CURDATE()) AS days_remaining,
    CASE 
        WHEN DATEDIFF(c.end_date, CURDATE()) <= 7 THEN '紧急'
        WHEN DATEDIFF(c.end_date, CURDATE()) <= 15 THEN '重要'
        ELSE '注意'
    END AS alert_level
FROM contract c
JOIN employee e ON c.emp_id = e.emp_id
LEFT JOIN department d ON e.dept_id = d.dept_id
LEFT JOIN position p ON e.pos_id = p.pos_id
WHERE c.status = '有效' 
  AND c.end_date IS NOT NULL
  AND DATEDIFF(c.end_date, CURDATE()) BETWEEN 0 AND 30
ORDER BY days_remaining;
```

**技术要点**:
- 使用 `DATEDIFF()` 函数计算剩余天数
- 使用 `CASE WHEN` 实现多级预警
- 使用 `BETWEEN` 筛选30天内到期的合同
- 动态计算，实时反映合同状态

**应用场景**: 合同管理、预警提醒

#### 4. 月度考勤异常统计视图（v_attendance_monthly_stats）
```sql
CREATE OR REPLACE VIEW v_attendance_monthly_stats AS
SELECT 
    e.emp_id,
    e.name,
    d.dept_name,
    DATE_FORMAT(a.work_date, '%Y-%m') AS month,
    COUNT(*) AS total_records,
    COUNT(CASE WHEN a.type = '正常' THEN 1 END) AS normal_days,
    COUNT(CASE WHEN a.type = '迟到' THEN 1 END) AS late_count,
    COUNT(CASE WHEN a.type = '早退' THEN 1 END) AS early_leave_count,
    COUNT(CASE WHEN a.type = '旷工' THEN 1 END) AS absence_count,
    COUNT(CASE WHEN a.type = '请假' THEN 1 END) AS leave_count,
    COUNT(CASE WHEN a.type = '出差' THEN 1 END) AS business_trip_count,
    SUM(a.hours) AS total_hours,
    COUNT(CASE WHEN a.type IN ('迟到', '早退', '旷工') THEN 1 END) AS abnormal_count
FROM employee e
LEFT JOIN department d ON e.dept_id = d.dept_id
LEFT JOIN attendance a ON e.emp_id = a.emp_id
WHERE e.status IN ('在职', '试用期')
GROUP BY e.emp_id, e.name, d.dept_name, month
HAVING month IS NOT NULL;
```

**技术要点**:
- 使用 `DATE_FORMAT()` 函数按月分组
- 多条件聚合统计各种考勤类型
- 使用 `SUM()` 计算总工时
- `HAVING` 子句过滤空月份

**应用场景**: 考勤统计、绩效考核

#### 5. 员工综合信息视图（v_employee_comprehensive）
```sql
CREATE OR REPLACE VIEW v_employee_comprehensive AS
SELECT 
    e.emp_id,
    e.name,
    e.gender,
    e.phone,
    e.hire_date,
    e.status,
    d.dept_name,
    p.pos_name,
    p.base_salary,
    p.level,
    TIMESTAMPDIFF(MONTH, e.hire_date, CURDATE()) AS work_months,
    TIMESTAMPDIFF(YEAR, e.hire_date, CURDATE()) AS work_years,
    (SELECT COUNT(*) FROM contract WHERE emp_id = e.emp_id) AS contract_count,
    (SELECT MAX(end_date) FROM contract WHERE emp_id = e.emp_id AND status = '有效') AS current_contract_end,
    (SELECT COUNT(*) FROM attendance 
     WHERE emp_id = e.emp_id 
     AND work_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)) AS recent_attendance_count,
    (SELECT COUNT(*) FROM emp_training_relation WHERE emp_id = e.emp_id) AS training_count,
    (SELECT COUNT(*) FROM emp_training_relation WHERE emp_id = e.emp_id AND is_completed = TRUE) AS completed_training_count
FROM employee e
LEFT JOIN department d ON e.dept_id = d.dept_id
LEFT JOIN position p ON e.pos_id = p.pos_id;
```

**技术要点**:
- 使用 `TIMESTAMPDIFF()` 计算工龄
- 使用子查询统计合同、考勤、培训信息
- 使用 `DATE_SUB()` 计算最近30天
- 综合多表信息，提供一站式查询

**应用场景**: 员工档案查询、综合报表

### 视图的优势

1. **数据安全性**: 隐藏敏感信息，控制数据访问
2. **查询简化**: 封装复杂查询逻辑
3. **逻辑独立性**: 视图结构变化不影响应用程序
4. **性能优化**: 可以基于视图创建索引（物化视图）

---

## 触发器（Trigger）

### 触发器概述
触发器是数据库自动执行的存储过程，在特定事件（INSERT、UPDATE、DELETE）发生时自动触发。

### 触发器列表

#### 1. 入职触发器（trg_log_entry）
```sql
CREATE TRIGGER trg_log_entry
    AFTER INSERT ON employee
    FOR EACH ROW
BEGIN
    DECLARE v_dept_name VARCHAR(50);
    DECLARE v_pos_name VARCHAR(50);

    SELECT dept_name INTO v_dept_name FROM department WHERE dept_id = NEW.dept_id;
    SELECT pos_name INTO v_pos_name FROM position WHERE pos_id = NEW.pos_id;

    INSERT INTO job_change (
        emp_id, change_type,
        new_dept_name, new_pos_name,
        change_date, remarks
    )
    VALUES (
        NEW.emp_id, '入职',
        v_dept_name, v_pos_name,
        NOW(), '新员工入职办理'
    );
END
```

**技术要点**:
- **触发时机**: `AFTER INSERT`，在插入员工记录之后触发
- **变量声明**: 使用 `DECLARE` 声明局部变量
- **NEW 关键字**: 引用新插入的记录
- **SELECT INTO**: 将查询结果赋值给变量
- **自动记录**: 自动在 `job_change` 表中记录入职信息

**应用场景**: 新员工入职时自动记录人事变动

#### 2. 人事变动触发器（trg_log_job_change）
```sql
CREATE TRIGGER trg_log_job_change
    AFTER UPDATE ON employee
    FOR EACH ROW
BEGIN
    DECLARE v_old_dept VARCHAR(50);
    DECLARE v_new_dept VARCHAR(50);
    DECLARE v_old_pos VARCHAR(50);
    DECLARE v_new_pos VARCHAR(50);

    IF OLD.dept_id != NEW.dept_id OR OLD.pos_id != NEW.pos_id THEN
        SELECT dept_name INTO v_old_dept FROM department WHERE dept_id = OLD.dept_id;
        SELECT dept_name INTO v_new_dept FROM department WHERE dept_id = NEW.dept_id;
        SELECT pos_name INTO v_old_pos FROM position WHERE pos_id = OLD.pos_id;
        SELECT pos_name INTO v_new_pos FROM position WHERE pos_id = NEW.pos_id;
    END IF;

    -- 转正逻辑
    IF OLD.status = '试用期' AND NEW.status = '在职' THEN
        INSERT INTO job_change (...) VALUES (...);
    END IF;

    -- 离职逻辑
    IF OLD.status != '离职' AND NEW.status = '离职' THEN
        INSERT INTO job_change (...) VALUES (...);
    END IF;

    -- 调动逻辑
    IF NEW.status != '离职' AND OLD.dept_id != NEW.dept_id THEN
        INSERT INTO job_change (...) VALUES (...);
    END IF;

    -- 晋升逻辑
    IF NEW.status != '离职' AND OLD.dept_id = NEW.dept_id AND OLD.pos_id != NEW.pos_id THEN
        INSERT INTO job_change (...) VALUES (...);
    END IF;
END
```

**技术要点**:
- **触发时机**: `AFTER UPDATE`，在更新员工记录之后触发
- **OLD/NEW 关键字**: `OLD` 引用更新前的记录，`NEW` 引用更新后的记录
- **条件判断**: 使用 `IF-THEN-ELSEIF` 实现多分支逻辑
- **业务规则**: 自动识别转正、离职、调动、晋升等不同场景
- **快照保存**: 保存部门和职位名称快照，避免历史数据丢失

**应用场景**: 员工状态或岗位变更时自动记录人事变动历史

#### 3. 培训自动完成触发器（trg_training_auto_complete）
```sql
CREATE TRIGGER trg_training_auto_complete
BEFORE UPDATE ON emp_training_relation
FOR EACH ROW
BEGIN
    IF NEW.score IS NOT NULL AND NEW.score >= 60 AND OLD.is_completed = FALSE THEN
        SET NEW.is_completed = TRUE;
    END IF;
END
```

**技术要点**:
- **触发时机**: `BEFORE UPDATE`，在更新之前触发，可以修改新值
- **条件判断**: 成绩>=60分且之前未完成时，自动标记为已完成
- **数据修改**: 使用 `SET NEW.is_completed = TRUE` 修改更新后的值

**应用场景**: 录入培训成绩时自动判断是否完成

#### 4. 合同日期检查触发器（trg_contract_date_check）
```sql
CREATE TRIGGER trg_contract_date_check
BEFORE INSERT ON contract
FOR EACH ROW
BEGIN
    IF NEW.end_date IS NOT NULL AND NEW.end_date <= NEW.start_date THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '合同结束日期必须晚于开始日期';
    END IF;
    
    IF NEW.end_date IS NOT NULL AND NEW.end_date < CURDATE() THEN
        SET NEW.status = '过期';
    END IF;
END
```

**技术要点**:
- **触发时机**: `BEFORE INSERT`，在插入之前触发
- **数据验证**: 检查日期合法性
- **错误处理**: 使用 `SIGNAL` 抛出自定义错误
- **自动设置**: 过期合同自动设置状态为'过期'

**应用场景**: 插入合同时自动验证数据合法性并设置状态

#### 5. 部门删除检查触发器（trg_dept_delete_check）
```sql
CREATE TRIGGER trg_dept_delete_check
BEFORE DELETE ON department
FOR EACH ROW
BEGIN
    DECLARE emp_count INT;
    SELECT COUNT(*) INTO emp_count FROM employee WHERE dept_id = OLD.dept_id;
    
    IF emp_count > 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '该部门还有员工，无法删除';
    END IF;
END
```

**技术要点**:
- **触发时机**: `BEFORE DELETE`，在删除之前触发
- **业务规则检查**: 检查部门是否还有员工
- **阻止删除**: 如果有员工，抛出错误阻止删除操作

**应用场景**: 防止误删除有员工的部门

#### 6. 工资调整日志触发器（trg_log_salary_adjustment）
```sql
CREATE TRIGGER trg_log_salary_adjustment
AFTER UPDATE ON position
FOR EACH ROW
BEGIN
    IF OLD.base_salary != NEW.base_salary THEN
        INSERT INTO salary_adjustment_log 
            (pos_id, pos_name, old_salary, new_salary, adjustment_rate)
        VALUES (
            NEW.pos_id, 
            NEW.pos_name,
            OLD.base_salary, 
            NEW.base_salary,
            ROUND((NEW.base_salary - OLD.base_salary) / OLD.base_salary * 100, 2)
        );
    END IF;
END
```

**技术要点**:
- **触发时机**: `AFTER UPDATE`，在更新职位表之后触发
- **变更检测**: 比较新旧工资值
- **自动计算**: 计算调整幅度百分比
- **审计记录**: 自动记录所有工资调整历史

**应用场景**: 工资调整时自动记录审计日志

### 触发器的优势

1. **自动化**: 减少应用程序代码，提高开发效率
2. **数据一致性**: 保证业务规则自动执行
3. **审计追踪**: 自动记录数据变更历史
4. **数据验证**: 在数据库层面保证数据合法性

---

## 存储过程（Stored Procedure）

### 存储过程概述
存储过程是预编译的 SQL 语句集合，可以接受参数，执行复杂业务逻辑，提高性能和代码复用。

### 存储过程列表

#### 1. 月度工资计算存储过程（sp_calc_monthly_salary）
```sql
CREATE PROCEDURE sp_calc_monthly_salary(IN p_month VARCHAR(7))
BEGIN
    SELECT
        e.emp_id,
        e.name,
        p.base_salary AS '基本工资',
        COALESCE((SELECT SUM(amount) FROM reward_punish rp
                  WHERE rp.emp_id = e.emp_id 
                  AND DATE_FORMAT(rp.event_date, '%Y-%m') = p_month), 0) AS '奖惩绩效',
        (SELECT COUNT(*) FROM attendance a
         WHERE a.emp_id = e.emp_id 
         AND a.type = '迟到' 
         AND DATE_FORMAT(a.work_date, '%Y-%m') = p_month) * 50.00 AS '考勤扣款',
        (p.base_salary + ...) AS '实发工资'
    FROM employee e
    JOIN position p ON e.pos_id = p.pos_id
    WHERE e.status != '离职';
END
```

**技术要点**:
- **输入参数**: `IN p_month VARCHAR(7)` 指定月份
- **子查询**: 使用相关子查询计算奖惩总额和考勤扣款
- **COALESCE**: 处理 NULL 值，避免计算错误
- **日期函数**: 使用 `DATE_FORMAT()` 按月筛选数据
- **复杂计算**: 基本工资 + 奖惩 - 扣款 = 实发工资

**应用场景**: 每月计算所有员工的工资明细

#### 2. 员工转正存储过程（sp_employee_confirmation）
```sql
CREATE PROCEDURE sp_employee_confirmation(
    IN p_emp_id INT,
    OUT p_result VARCHAR(200)
)
BEGIN
    DECLARE emp_status VARCHAR(20);
    DECLARE hire_months INT;
    DECLARE emp_name VARCHAR(50);
    
    SELECT status, name, TIMESTAMPDIFF(MONTH, hire_date, CURDATE())
    INTO emp_status, emp_name, hire_months
    FROM employee WHERE emp_id = p_emp_id;
    
    IF emp_status IS NULL THEN
        SET p_result = '失败：员工不存在';
    ELSEIF emp_status != '试用期' THEN
        SET p_result = CONCAT('失败：员工', emp_name, '当前状态为', emp_status, '，不是试用期');
    ELSEIF hire_months < 1 THEN
        SET p_result = CONCAT('失败：试用期不满1个月，当前', hire_months, '个月');
    ELSE
        UPDATE employee SET status = '在职' WHERE emp_id = p_emp_id;
        SET p_result = CONCAT('成功：员工', emp_name, '已转正，工龄', hire_months, '个月');
    END IF;
END
```

**技术要点**:
- **输入输出参数**: `IN` 参数传入员工ID，`OUT` 参数返回结果
- **变量声明**: 使用 `DECLARE` 声明局部变量
- **SELECT INTO**: 将查询结果赋值给多个变量
- **业务规则验证**: 检查员工状态、试用期时长
- **条件分支**: 使用 `IF-ELSEIF-ELSE` 实现多分支逻辑
- **字符串拼接**: 使用 `CONCAT()` 函数拼接结果信息
- **自动触发**: 更新状态后，触发器会自动记录转正日志

**应用场景**: 员工转正操作，包含完整的业务验证

#### 3. 批量考勤录入存储过程（sp_batch_attendance）
```sql
CREATE PROCEDURE sp_batch_attendance(
    IN p_dept_id INT,
    IN p_work_date DATE,
    IN p_type VARCHAR(20),
    OUT p_affected_rows INT
)
BEGIN
    INSERT INTO attendance (emp_id, work_date, type, hours)
    SELECT 
        emp_id, 
        p_work_date, 
        p_type,
        CASE 
            WHEN p_type = '正常' THEN 8.0
            WHEN p_type = '请假' THEN 0
            WHEN p_type = '出差' THEN 8.0
            ELSE 8.0
        END AS hours
    FROM employee
    WHERE dept_id = p_dept_id 
      AND status IN ('在职', '试用期')
      AND NOT EXISTS (
          SELECT 1 FROM attendance 
          WHERE emp_id = employee.emp_id 
          AND work_date = p_work_date
      );
    
    SET p_affected_rows = ROW_COUNT();
END
```

**技术要点**:
- **批量操作**: 使用 `INSERT INTO ... SELECT` 批量插入
- **条件插入**: 使用 `NOT EXISTS` 防止重复录入
- **CASE 表达式**: 根据考勤类型自动计算工时
- **行数统计**: 使用 `ROW_COUNT()` 返回影响行数

**应用场景**: 批量为部门员工录入考勤记录

#### 4. 部门月度考勤汇总存储过程（sp_dept_attendance_summary）
```sql
CREATE PROCEDURE sp_dept_attendance_summary(
    IN p_dept_id INT,
    IN p_month VARCHAR(7)
)
BEGIN
    SELECT 
        e.emp_id,
        e.name,
        d.dept_name,
        COUNT(CASE WHEN a.type = '正常' THEN 1 END) AS normal_days,
        COUNT(CASE WHEN a.type = '迟到' THEN 1 END) AS late_days,
        COUNT(CASE WHEN a.type = '早退' THEN 1 END) AS early_leave_days,
        COUNT(CASE WHEN a.type = '旷工' THEN 1 END) AS absence_days,
        COUNT(CASE WHEN a.type = '请假' THEN 1 END) AS leave_days,
        COUNT(CASE WHEN a.type = '出差' THEN 1 END) AS business_trip_days,
        SUM(a.hours) AS total_hours,
        ROUND(SUM(a.hours) / 22 * 100, 2) AS attendance_rate
    FROM employee e
    JOIN department d ON e.dept_id = d.dept_id
    LEFT JOIN attendance a ON e.emp_id = a.emp_id 
        AND DATE_FORMAT(a.work_date, '%Y-%m') = p_month
    WHERE (p_dept_id IS NULL OR e.dept_id = p_dept_id)
      AND e.status IN ('在职', '试用期')
    GROUP BY e.emp_id, e.name, d.dept_name
    ORDER BY late_days DESC, absence_days DESC;
END
```

**技术要点**:
- **可选参数**: `p_dept_id` 为 NULL 时查询所有部门
- **条件聚合**: 使用 `COUNT(CASE WHEN ...)` 统计各种考勤类型
- **出勤率计算**: 使用 `ROUND()` 计算并格式化出勤率
- **排序**: 按异常考勤降序排列，突出问题员工

**应用场景**: 部门月度考勤统计报表

#### 5. 员工综合绩效评估存储过程（sp_employee_performance）
```sql
CREATE PROCEDURE sp_employee_performance(
    IN p_emp_id INT,
    IN p_month VARCHAR(7)
)
BEGIN
    DECLARE v_base_salary DECIMAL(10,2);
    DECLARE v_reward_total DECIMAL(10,2);
    DECLARE v_late_count INT;
    DECLARE v_absence_count INT;
    DECLARE v_training_complete INT;
    DECLARE v_work_years DECIMAL(5,2);
    DECLARE v_performance_score DECIMAL(5,2);
    
    -- 获取各项数据
    SELECT p.base_salary INTO v_base_salary FROM ...;
    SELECT COALESCE(SUM(amount), 0) INTO v_reward_total FROM ...;
    SELECT COUNT(...) INTO v_late_count, v_absence_count FROM ...;
    SELECT COUNT(*) INTO v_training_complete FROM ...;
    SET v_work_years = fn_calc_work_years(p_emp_id);
    
    -- 计算综合绩效分
    SET v_performance_score = 100 
        + (v_reward_total / 100)
        - (v_late_count * 2)
        - (v_absence_count * 10)
        + (v_training_complete * 5)
        + (v_work_years * 2);
    
    -- 输出结果
    SELECT ...;
END
```

**技术要点**:
- **多变量声明**: 声明多个变量存储不同维度的数据
- **数据收集**: 从多个表收集数据
- **函数调用**: 调用自定义函数 `fn_calc_work_years()`
- **综合算法**: 实现复杂的绩效评分算法
- **结果输出**: 使用 `SELECT` 返回评估结果

**应用场景**: 员工月度绩效综合评估

### 存储过程的优势

1. **性能优化**: 预编译执行，减少网络传输
2. **代码复用**: 一次编写，多处调用
3. **业务封装**: 将复杂业务逻辑封装在数据库层
4. **安全性**: 可以控制数据访问权限
5. **事务支持**: 保证操作的原子性

---

## 自定义函数（Function）

### 函数概述
自定义函数是用户定义的函数，可以接受参数并返回单一值，用于封装常用计算逻辑。

### 函数列表

#### 1. 计算工龄函数（fn_calc_work_years）
```sql
CREATE FUNCTION fn_calc_work_years(p_emp_id INT)
RETURNS DECIMAL(5,2)
DETERMINISTIC
BEGIN
    DECLARE hire_dt DATE;
    DECLARE years DECIMAL(5,2);
    
    SELECT hire_date INTO hire_dt FROM employee WHERE emp_id = p_emp_id;
    
    IF hire_dt IS NULL THEN
        RETURN 0;
    END IF;
    
    SET years = TIMESTAMPDIFF(MONTH, hire_dt, CURDATE()) / 12.0;
    RETURN years;
END
```

**技术要点**:
- **返回值类型**: `RETURNS DECIMAL(5,2)` 指定返回小数
- **DETERMINISTIC**: 声明为确定性函数，相同输入总是返回相同输出
- **日期计算**: 使用 `TIMESTAMPDIFF()` 计算月份差，除以12转换为年
- **NULL 处理**: 处理入职日期为空的情况

**应用场景**: 在查询中直接调用计算员工工龄

#### 2. 获取员工级别函数（fn_get_employee_grade）
```sql
CREATE FUNCTION fn_get_employee_grade(p_emp_id INT)
RETURNS VARCHAR(20)
DETERMINISTIC
BEGIN
    DECLARE work_years DECIMAL(5,2);
    DECLARE grade VARCHAR(20);
    
    SET work_years = fn_calc_work_years(p_emp_id);
    
    IF work_years < 1 THEN
        SET grade = '新员工';
    ELSEIF work_years < 3 THEN
        SET grade = '初级';
    ELSEIF work_years < 5 THEN
        SET grade = '中级';
    ELSEIF work_years < 10 THEN
        SET grade = '高级';
    ELSE
        SET grade = '资深';
    END IF;
    
    RETURN grade;
END
```

**技术要点**:
- **函数嵌套**: 调用另一个自定义函数 `fn_calc_work_years()`
- **多分支判断**: 使用 `IF-ELSEIF-ELSE` 实现分级逻辑
- **业务规则**: 根据工龄自动划分员工级别

**应用场景**: 根据工龄自动判断员工级别

#### 3. 计算部门平均工资函数（fn_dept_avg_salary）
```sql
CREATE FUNCTION fn_dept_avg_salary(p_dept_id INT)
RETURNS DECIMAL(10,2)
READS SQL DATA
BEGIN
    DECLARE avg_sal DECIMAL(10,2);
    
    SELECT AVG(p.base_salary) INTO avg_sal
    FROM employee e
    JOIN position p ON e.pos_id = p.pos_id
    WHERE e.dept_id = p_dept_id AND e.status IN ('在职', '试用期');
    
    RETURN IFNULL(avg_sal, 0);
END
```

**技术要点**:
- **READS SQL DATA**: 声明函数会读取数据库数据
- **聚合函数**: 使用 `AVG()` 计算平均值
- **多表连接**: 连接员工表和职位表
- **条件过滤**: 只统计在职和试用期员工
- **NULL 处理**: 使用 `IFNULL()` 处理空值

**应用场景**: 计算部门平均工资，用于统计分析

### 函数与存储过程的区别

| 特性 | 函数 | 存储过程 |
|------|------|----------|
| 返回值 | 必须返回单一值 | 可以返回多个结果集 |
| 调用方式 | 在 SQL 语句中使用 | 使用 CALL 调用 |
| 参数 | 只有输入参数 | 可以有输入/输出参数 |
| 用途 | 计算、转换 | 复杂业务逻辑 |
| SELECT | 可以在 SELECT 中使用 | 不能在 SELECT 中使用 |

### 函数的优势

1. **代码复用**: 封装常用计算逻辑
2. **简化查询**: 在 SQL 中直接调用，简化查询语句
3. **一致性**: 保证计算逻辑的一致性
4. **性能**: 预编译执行，提高性能

---

## 事件调度器（Event Scheduler）

### 事件调度器概述
事件调度器是 MySQL 提供的定时任务功能，可以在指定时间自动执行 SQL 语句。

### 事件列表

#### 1. 自动更新过期合同事件（evt_update_expired_contracts）
```sql
CREATE EVENT evt_update_expired_contracts
ON SCHEDULE EVERY 1 DAY
STARTS CURRENT_DATE + INTERVAL 1 DAY
COMMENT '每天自动检查并更新过期合同状态'
DO
BEGIN
    UPDATE contract 
    SET status = '过期'
    WHERE status = '有效' 
      AND end_date < CURDATE()
      AND end_date IS NOT NULL;
END
```

**技术要点**:
- **调度频率**: `EVERY 1 DAY` 每天执行一次
- **开始时间**: `STARTS CURRENT_DATE + INTERVAL 1 DAY` 从明天开始
- **自动更新**: 自动将过期合同状态更新为'过期'
- **条件筛选**: 只更新有效且已过期的合同

**应用场景**: 每天凌晨自动检查并更新合同状态

#### 2. 月度考勤汇总事件（evt_monthly_attendance_summary）
```sql
CREATE EVENT evt_monthly_attendance_summary
ON SCHEDULE EVERY 1 MONTH
STARTS CONCAT(DATE_FORMAT(DATE_ADD(LAST_DAY(CURDATE()), INTERVAL 1 DAY), '%Y-%m-%d'), ' 02:00:00')
COMMENT '每月1号生成上月考勤汇总'
DO
BEGIN
    DECLARE last_month VARCHAR(7);
    SET last_month = DATE_FORMAT(DATE_SUB(CURDATE(), INTERVAL 1 MONTH), '%Y-%m');
    
    INSERT INTO attendance_monthly_summary (...)
    SELECT ...
    FROM employee e
    LEFT JOIN attendance a ON ...
    WHERE e.status IN ('在职', '试用期')
    GROUP BY e.emp_id
    ON DUPLICATE KEY UPDATE ...;
END
```

**技术要点**:
- **调度频率**: `EVERY 1 MONTH` 每月执行一次
- **开始时间**: 每月1号凌晨2点执行
- **日期计算**: 使用 `DATE_SUB()` 计算上个月
- **批量插入**: 使用 `INSERT INTO ... SELECT` 批量生成汇总数据
- **更新策略**: 使用 `ON DUPLICATE KEY UPDATE` 实现插入或更新

**应用场景**: 每月自动生成上月考勤汇总数据，提高查询性能

### 启用事件调度器
```sql
SET GLOBAL event_scheduler = ON;
```

### 事件调度器的优势

1. **自动化**: 无需人工干预，自动执行定时任务
2. **可靠性**: 数据库层面保证任务执行
3. **性能优化**: 预计算汇总数据，提高查询性能
4. **数据维护**: 自动维护数据状态

---

## 数据完整性约束

### CHECK 约束（MySQL 8.0.16+）

#### 1. 身份证号长度检查
```sql
ALTER TABLE employee
ADD CONSTRAINT chk_id_card_length CHECK (CHAR_LENGTH(id_card) = 18);
```
**作用**: 确保身份证号必须是18位

#### 2. 奖惩金额合理性检查
```sql
ALTER TABLE reward_punish
ADD CONSTRAINT chk_amount_reasonable CHECK (amount BETWEEN -10000 AND 10000);
```
**作用**: 限制奖惩金额在合理范围内

#### 3. 工作时长有效性检查
```sql
ALTER TABLE attendance
ADD CONSTRAINT chk_hours_valid CHECK (hours BETWEEN 0 AND 24);
```
**作用**: 确保工作时长在0-24小时之间

#### 4. 培训成绩范围检查
```sql
ALTER TABLE emp_training_relation
ADD CONSTRAINT chk_score_range CHECK (score IS NULL OR (score >= 0 AND score <= 100));
```
**作用**: 确保成绩在0-100分之间，或为NULL

### 约束的作用

1. **域完整性**: 确保字段值在有效范围内
2. **数据质量**: 在数据库层面保证数据质量
3. **业务规则**: 将业务规则固化在数据库中
4. **错误预防**: 在插入/更新时自动检查，防止无效数据

---

## 数据库技术总结

### 技术点统计

| 技术类型 | 数量 | 主要应用 |
|---------|------|---------|
| 数据表 | 12张 | 存储业务数据 |
| 主键索引 | 12个 | 唯一标识记录 |
| 唯一索引 | 5个 | 保证数据唯一性 |
| 普通索引 | 6个 | 提高查询性能 |
| 复合索引 | 5个 | 优化多字段查询 |
| 外键约束 | 11个 | 保证参照完整性 |
| 视图 | 5个 | 数据安全、查询简化 |
| 触发器 | 6个 | 自动化业务逻辑 |
| 存储过程 | 5个 | 复杂业务处理 |
| 自定义函数 | 3个 | 计算逻辑封装 |
| 事件调度器 | 2个 | 定时任务执行 |
| CHECK约束 | 4个 | 数据域完整性 |

### 核心技术亮点

#### 1. 完整的数据库设计
- ✅ 规范化设计（1NF、2NF、3NF）
- ✅ 合理的实体关系设计
- ✅ 完善的索引优化策略

#### 2. 数据完整性保障
- ✅ 主键约束（实体完整性）
- ✅ 外键约束（参照完整性）
- ✅ CHECK约束（域完整性）
- ✅ 触发器验证（业务完整性）

#### 3. 性能优化技术
- ✅ 合理的索引设计（主键、唯一、复合索引）
- ✅ 视图预计算（减少复杂查询）
- ✅ 汇总表设计（月度考勤汇总）
- ✅ 事件调度器预计算

#### 4. 业务自动化
- ✅ 触发器自动记录人事变动
- ✅ 触发器自动更新合同状态
- ✅ 触发器自动标记培训完成
- ✅ 事件调度器自动维护数据

#### 5. 数据安全性
- ✅ 视图实现数据脱敏（身份证号）
- ✅ 视图控制数据访问
- ✅ 触发器防止误操作（部门删除检查）

#### 6. 复杂业务处理
- ✅ 存储过程实现工资计算
- ✅ 存储过程实现绩效评估
- ✅ 存储过程实现批量操作
- ✅ 函数封装常用计算

### 数据库应用价值

1. **教学价值**: 涵盖了数据库课程的核心知识点
2. **实践价值**: 完整的业务场景，贴近实际应用
3. **技术深度**: 从基础到高级，全面展示数据库技术
4. **可扩展性**: 良好的设计便于后续扩展

### 技术学习要点

#### 基础层面
- 表结构设计（字段类型、约束）
- 主键和外键的使用
- 索引的创建和优化

#### 中级层面
- 视图的创建和使用
- 触发器的编写和应用
- 存储过程的设计

#### 高级层面
- 自定义函数的开发
- 事件调度器的配置
- 复杂业务逻辑的实现

---

## 附录：数据库对象查询语句

### 查看所有表
```sql
SHOW TABLES;
```

### 查看表结构
```sql
DESC table_name;
-- 或
SHOW CREATE TABLE table_name;
```

### 查看所有视图
```sql
SHOW FULL TABLES WHERE TABLE_TYPE = 'VIEW';
```

### 查看所有存储过程
```sql
SHOW PROCEDURE STATUS WHERE Db = 'epms_final_db';
```

### 查看所有函数
```sql
SHOW FUNCTION STATUS WHERE Db = 'epms_final_db';
```

### 查看所有触发器
```sql
SHOW TRIGGERS;
```

### 查看所有事件
```sql
SHOW EVENTS;
```

### 查看表索引
```sql
SHOW INDEX FROM table_name;
```

### 查看外键约束
```sql
SELECT 
    TABLE_NAME,
    COLUMN_NAME,
    CONSTRAINT_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = 'epms_final_db'
  AND REFERENCED_TABLE_NAME IS NOT NULL;
```

---

**报告生成时间**: 2024年
**数据库版本**: MySQL 5.7+ / 8.0+
**项目名称**: EPMS 人事管理系统
